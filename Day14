 226.翻转二叉树 （优先掌握递归）
这道题开始需要严格的follow代码随想录里面给出的三步走
#1.确定递归函数的参数及返回值
#2. 确定终止条件
#3.确定单层递归的逻辑

这一道题的本质是前序遍历，中左右
示例分析：
    1
   / \
  2   3
 / \
4   5

过程详解

    根节点 1:

        交换 root.left 和 root.right，即交换 2 和 3。

        树的结构现在是：


        1
       / \
      3   2
         / \
        4   5

    递归翻转左子树（根节点 3）和右子树（根节点 2）。

递归翻转左子树（根节点 3）:

    交换 root.left 和 root.right，即交换 None 和 None（没有子节点，结构不变）。

    树的结构现在是：


        1
       / \
      3   2
         / \
        4   5

    左子树（根节点 3）翻转完成。

递归翻转右子树（根节点 2）:

    交换 root.left 和 root.right，即交换 4 和 5。

    树的结构现在是：

        1
       / \
      3   2
         / \
        5   4

    递归翻转左子树（根节点 5）和右子树（根节点 4）。

递归翻转节点 5 和 4（叶子节点）:

    节点 5 和 4 没有子节点，翻转不改变结构。

    树的结构保持不变：


    1
   / \
  3   2
     / \
    5   4

 101. 对称二叉树 （优先掌握递归） 



 104.二叉树的最大深度 （优先掌握递归）
       1
     /   \
    2     3
   / \   / 
  4   5 6   
对于这个树结构，后序遍历和深度计算的过程如下：

    从根节点1开始，调用getdepth(1)。
    在getdepth(1)中，调用getdepth(2)。
    在getdepth(2)中，调用getdepth(4)。
    在getdepth(4)中，调用getdepth(None)两次，返回0。计算出节点4的深度为1。
    回到getdepth(2)，调用getdepth(5)。
    在getdepth(5)中，调用getdepth(None)两次，返回0。计算出节点5的深度为1。
    回到getdepth(2)，计算出节点2的深度为1 + max(1, 1) = 2。
    回到getdepth(1)，调用getdepth(3)。
    在getdepth(3)中，调用getdepth(None)两次，返回0。计算出节点3的深度为1。
    回到getdepth(1)，计算出节点1的深度为1 + max(2, 1) = 3。
使用递归，需要理解这道题是后序遍历的左右中


 111.二叉树的最小深度 （优先掌握递归）

这一道题需要注意的点在于，左右节点都是None才能算是叶节点
      1
     /
    2
   / \
  4   3
     / \
    6   5
这个最大深度不是1而是3
另外，这道题还要注意递归结束之后，不能直接取最小值
if node.left is None and node.right is not None: 
        return 1 + rightheight
右，中同理


