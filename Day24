93.复原IP地址  
这一道题跟上一道题目很类似，就是使用StartIndex来代表切割的线
剪枝操作：
        if len(path) > 4:  # 剪枝
            return


 78.子集  

这一道题跟之前的区别在于，之前都是在树的叶子节点获得我们的结果
这道题是在每一层递归的时候都要获得我们的结果

问题 1: self.result.append(path[:]) 为什么要放在 for 循环的外面？
将 self.result.append(path[:]) 放在 for 循环的外面是因为我们想在每次进入新的递归层级时，都记录当前路径 path 作为一个新的子集。这意味着，无论当前路径中包含哪些元素，它都应该被记录下来作为一个有效的子集。
如果把这句话放在 for 循环里面，那么只有在添加了新的元素之后，当前路径才会被记录，这样会漏掉一些子集。例如，空集 [] 就不会被记录，因为在进入 for 循环之前路径是空的。

问题 2: 为什么要写成 path[:]，而不是直接写成 path？
path[:] 表示的是对当前路径的一个浅拷贝，而直接使用 path 会导致所有的引用指向同一个列表。
如果直接写成 self.result.append(path)，那么 result 中所有添加的路径实际上都是同一个列表的引用。这样，当 path 在后续的递归和回溯过程中发生变化时，result 中的所有引用也会随之改变，最终你得到的所有子集都会是相同的，等于最后 path 的状态。

 90.子集II 
