24. Swap Nodes in Pairs
两两交换， 假设说有一个链表 1->2->3->4->5,加上dummy_head之后本质上就是dummy_head->2->1->3,以此类推。
为什么这一道链表的题需要用两个临时的变量来存储节点的位置？
注意return 的缩进问题

19.删除链表的倒数第N个节点  
根据链表的删除操作，我们需要让指针指向要删除节点的前一个节点
思路：定义两个指针，一个快指针一个慢指针，先让快指针走N+1步（由于要指向前一个节点,可以用一个单独的for循环来实现）。
慢指针初始为0。后快快慢指针同时移动直到快指针指向None
（这个想法真有点意思





160.链表相交
分别求两个链表的长度，然后分别定义指针之后，长的链表先移动（M-N）步，MN分别为两个链表的长度
然后开始遍历，判断节点是否一致

在第二次写这个代码的时候发现了如下的错误：
在判断两个链表是否相交时，我们关心的是节点引用而不是节点值。两个链表在某个节点相交意味着它们从某个节点开始共享同一个链表部分，即这些节点具有相同的内存地址。因此，我们应该比较节点的引用，而不是它们的值。
while curA:
    if curA == curB:
        return curA
    else:
        curA.next
        curB.next

下面是获取链表长度的一个方法
==========
while cur:         # 求链表A的长度
            cur = cur.next 
            lenA += 1
===========


142.环形链表II
这里可以的出来X=Z（或者说X = （n-1）(y+z) + z, (y+z)为一圈，n为转了几圈），知道这个结论的前提下，定义两个index都走一步，index1为从相遇点开始的，index2为从头开始的。
然后用X=Z去作为判断条件
