
一、二叉树的种类

1. 满二叉树
满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
如果K是深度，满二叉树的几点数量就是(2^K -1)


2. 完全二叉树
完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
堆就是一个完全二叉树


3. 二叉搜索树
定义：左子树的所有节点都小于中间的节点，右子树的所有节点都大于中间节点



4. 平衡二叉搜索树
又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

二、存储方式

1. 链式存储
链式存储方式就用指针
每一个节点会首先有一个节点元素，有一个左指针，会有一个右指针

2. 顺序存储
顺序存储的方式就是用数组
如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2

三、二叉树的遍历方式
1. 深度优先遍历
先往深走，遇到叶子节点再往回走。
前序遍历（递归法，迭代法） 中左右 
中序遍历（递归法，迭代法） 左中右  
后序遍历（递归法，迭代法） 左右中
- 这里前中后，其实指的就是中间节点的遍历顺序
        5
    4       6
1    2    7    8
假设说这是一个二叉树，
前序遍历： 5-4-1-2-6-7-8
中序遍历： 1-4-2-5-7-6-8 (可以理解为从左往右打开一个遮蔽的屏障)
后序遍历： 1-2-4-7-8-6-5

2. 广度优先遍历
层次遍历（迭代法）


二叉树的定义
class TreeNode:
    def __init__(self, val, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right

递归遍历的思考方式：
1. 确定递归函数的参数 和 返回值 
2. 确定终止条件
3. 确定单层递归的逻辑


前序遍历
        5
    4       6
1    2    7    8

让我们一步一步地遍历并记录结果列表的变化。

    根节点 5
        将 5 加入结果列表：[5]
        访问左子树 4
    节点 4
        将 4 加入结果列表：[5, 4]
        访问左子树 1
    节点 1
        将 1 加入结果列表：[5, 4, 1]
        左子树为空，返回
        右子树为空，返回
    返回节点 4
        访问右子树 2
    节点 2
        将 2 加入结果列表：[5, 4, 1, 2]
        左子树为空，返回
        右子树为空，返回
    返回根节点 5
        访问右子树 6
    节点 6
        将 6 加入结果列表：[5, 4, 1, 2, 6]
        访问左子树 7
    节点 7
        将 7 加入结果列表：[5, 4, 1, 2, 6, 7]
        左子树为空，返回
        右子树为空，返回
    返回节点 6
        访问右子树 8
    节点 8
        将 8 加入结果列表：[5, 4, 1, 2, 6, 7, 8]
        左子树为空，返回
        右子树为空，返回

最终的前序遍历结果是 [5, 4, 1, 2, 6, 7, 8]。


中序遍历
        5
    4       6
1    2    7    8

让我们一步一步地遍历并记录结果列表的变化。

    根节点 5
        访问左子树 4
    节点 4
        访问左子树 1
    节点 1
        左子树为空，返回
        将 1 加入结果列表：[1]
        右子树为空，返回
    返回节点 4
        将 4 加入结果列表：[1, 4]
        访问右子树 2
    节点 2
        左子树为空，返回
        将 2 加入结果列表：[1, 4, 2]
        右子树为空，返回
    返回根节点 5
        将 5 加入结果列表：[1, 4, 2, 5]
        访问右子树 6
    节点 6
        访问左子树 7
    节点 7
        左子树为空，返回
        将 7 加入结果列表：[1, 4, 2, 5, 7]
        右子树为空，返回
    返回节点 6
        将 6 加入结果列表：[1, 4, 2, 5, 7, 6]
        访问右子树 8
    节点 8
        左子树为空，返回
        将 8 加入结果列表：[1, 4, 2, 5, 7, 6, 8]
        右子树为空，返回

最终的中序遍历结果是 [1, 4, 2, 5, 7, 6, 8]。

后序遍历
        5
    4       6
1    2    7    8
后序遍历的顺序是左子树、右子树、根节点。让我们一步一步地递归遍历这棵树，并记录结果列表的变化。

    根节点 5
        访问左子树 4
    节点 4
        访问左子树 1
    节点 1
        左子树为空，返回
        右子树为空，返回
        将 1 加入结果列表：[1]
    返回节点 4
        访问右子树 2
    节点 2
        左子树为空，返回
        右子树为空，返回
        将 2 加入结果列表：[1, 2]
    返回节点 4
        左右子树遍历完毕，将 4 加入结果列表：[1, 2, 4]
    返回根节点 5
        访问右子树 6
    节点 6
        访问左子树 7
    节点 7
        左子树为空，返回
        右子树为空，返回
        将 7 加入结果列表：[1, 2, 4, 7]
    返回节点 6
        访问右子树 8
    节点 8
        左子树为空，返回
        右子树为空，返回
        将 8 加入结果列表：[1, 2, 4, 7, 8]
    返回节点 6
        左右子树遍历完毕，将 6 加入结果列表：[1, 2, 4, 7, 8, 6]
    返回根节点 5
        左右子树遍历完毕，将 5 加入结果列表：[1, 2, 4, 7, 8, 6, 5]
最终的后序遍历结果是 [1, 2, 4, 7, 8, 6, 5]。


二叉树的迭代遍历
主要使用栈来完成的

1. 前序遍历
        5
    4       6
1    2    7    8
我们期望前序遍历的结果是 [5, 4, 1, 2, 6, 7, 8]。

初始检查：

python

if not root:
    return []

    如果根节点 root 为空，则返回空列表。这里 root 不为空，继续执行。

初始化栈和结果列表：

python

result = []
stack = [root]

    初始化结果列表 result 为空。
    初始化栈 stack，并将根节点 5 压入栈中。此时 stack = [5]。

开始循环处理栈：

python

while stack:

    只要栈不为空，就继续循环。

弹出栈顶节点并处理：

python

node = stack.pop()
result.append(node.val)

    弹出栈顶节点 5 并将其值加入结果列表 result。此时 result = [5]，stack = []。

压入右子节点和左子节点：

python

if node.right:
    stack.append(node.right)
if node.left:
    stack.append(node.left)

    将节点 5 的右子节点 6 压入栈中，然后将左子节点 4 压入栈中。此时 stack = [6, 4]。

重复循环处理栈：

    弹出栈顶节点 4 并将其值加入结果列表 result。此时 result = [5, 4]，stack = [6]。

    将节点 4 的右子节点 2 压入栈中，然后将左子节点 1 压入栈中。此时 stack = [6, 2, 1]。

    弹出栈顶节点 1 并将其值加入结果列表 result。此时 result = [5, 4, 1]，stack = [6, 2]。

    节点 1 没有子节点，继续下一轮循环。

    弹出栈顶节点 2 并将其值加入结果列表 result。此时 result = [5, 4, 1, 2]，stack = [6]。

    节点 2 没有子节点，继续下一轮循环。

    弹出栈顶节点 6 并将其值加入结果列表 result。此时 result = [5, 4, 1, 2, 6]，stack = []。

    将节点 6 的右子节点 8 压入栈中，然后将左子节点 7 压入栈中。此时 stack = [8, 7]。

    弹出栈顶节点 7 并将其值加入结果列表 result。此时 result = [5, 4, 1, 2, 6, 7]，stack = [8]。

    节点 7 没有子节点，继续下一轮循环。

    弹出栈顶节点 8 并将其值加入结果列表 result。此时 result = [5, 4, 1, 2, 6, 7, 8]，stack = []。

    节点 8 没有子节点，继续下一轮循环。

2. 后序遍历
因为前序遍历是中左右，在代码执行中是先取中间的值，然后把右边的节点先压入栈（栈式后进先出），然后左边的节点后压入栈
所以就是中--左--右

所以对于后序遍历而言，是左右中，就对于前序遍历的压入栈的顺序换一下
即先压入左，右先出，所以就成了中右左
最后获得了结果再做一个反转即可result[::-1]
中右左变成了左右中，符合后序的条件了



3.中序遍历
跟前两个不同
由于我们一定是从根节点开始访问的。所以需要用一个指针来遍历节点，用栈来记录遍历过的元素


