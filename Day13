- 一、二叉树的种类

1. 满二叉树
满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
如果K是深度，满二叉树的几点数量就是(2^K -1)


2. 完全二叉树
完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
堆就是一个完全二叉树


3. 二叉搜索树
定义：左子树的所有节点都小于中间的节点，右子树的所有节点都大于中间节点



4. 平衡二叉搜索树
又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

二、存储方式

1. 链式存储
链式存储方式就用指针
每一个节点会首先有一个节点元素，有一个左指针，会有一个右指针

2. 顺序存储
顺序存储的方式就是用数组
如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2

三、二叉树的遍历方式
1. 深度优先遍历
先往深走，遇到叶子节点再往回走。
前序遍历（递归法，迭代法） 中左右 
中序遍历（递归法，迭代法） 左中右  
后序遍历（递归法，迭代法） 左右中
- 这里前中后，其实指的就是中间节点的遍历顺序
        5
    4       6
1    2    7    8
假设说这是一个二叉树，
前序遍历： 5-4-1-2-6-7-8
中序遍历： 1-4-2-5-7-6-8 (可以理解为从左往右打开一个遮蔽的屏障)
后序遍历： 1-2-4-7-8-6-5

2. 广度优先遍历
层次遍历（迭代法）


二叉树的定义
class TreeNode:
    def __init__(self, val, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right

递归遍历的思考方式：
1. 确定递归函数的参数 和 返回值 
2. 确定终止条件
3. 确定单层递归的逻辑


前序遍历
        5
    4       6
1    2    7    8

让我们一步一步地遍历并记录结果列表的变化。

    根节点 5
        将 5 加入结果列表：[5]
        访问左子树 4
    节点 4
        将 4 加入结果列表：[5, 4]
        访问左子树 1
    节点 1
        将 1 加入结果列表：[5, 4, 1]
        左子树为空，返回
        右子树为空，返回
    返回节点 4
        访问右子树 2
    节点 2
        将 2 加入结果列表：[5, 4, 1, 2]
        左子树为空，返回
        右子树为空，返回
    返回根节点 5
        访问右子树 6
    节点 6
        将 6 加入结果列表：[5, 4, 1, 2, 6]
        访问左子树 7
    节点 7
        将 7 加入结果列表：[5, 4, 1, 2, 6, 7]
        左子树为空，返回
        右子树为空，返回
    返回节点 6
        访问右子树 8
    节点 8
        将 8 加入结果列表：[5, 4, 1, 2, 6, 7, 8]
        左子树为空，返回
        右子树为空，返回

最终的前序遍历结果是 [5, 4, 1, 2, 6, 7, 8]。


中序遍历
        5
    4       6
1    2    7    8

让我们一步一步地遍历并记录结果列表的变化。

    根节点 5
        访问左子树 4
    节点 4
        访问左子树 1
    节点 1
        左子树为空，返回
        将 1 加入结果列表：[1]
        右子树为空，返回
    返回节点 4
        将 4 加入结果列表：[1, 4]
        访问右子树 2
    节点 2
        左子树为空，返回
        将 2 加入结果列表：[1, 4, 2]
        右子树为空，返回
    返回根节点 5
        将 5 加入结果列表：[1, 4, 2, 5]
        访问右子树 6
    节点 6
        访问左子树 7
    节点 7
        左子树为空，返回
        将 7 加入结果列表：[1, 4, 2, 5, 7]
        右子树为空，返回
    返回节点 6
        将 6 加入结果列表：[1, 4, 2, 5, 7, 6]
        访问右子树 8
    节点 8
        左子树为空，返回
        将 8 加入结果列表：[1, 4, 2, 5, 7, 6, 8]
        右子树为空，返回

最终的中序遍历结果是 [1, 4, 2, 5, 7, 6, 8]。

后序遍历
        5
    4       6
1    2    7    8
后序遍历的顺序是左子树、右子树、根节点。让我们一步一步地递归遍历这棵树，并记录结果列表的变化。

    根节点 5
        访问左子树 4
    节点 4
        访问左子树 1
    节点 1
        左子树为空，返回
        右子树为空，返回
        将 1 加入结果列表：[1]
    返回节点 4
        访问右子树 2
    节点 2
        左子树为空，返回
        右子树为空，返回
        将 2 加入结果列表：[1, 2]
    返回节点 4
        左右子树遍历完毕，将 4 加入结果列表：[1, 2, 4]
    返回根节点 5
        访问右子树 6
    节点 6
        访问左子树 7
    节点 7
        左子树为空，返回
        右子树为空，返回
        将 7 加入结果列表：[1, 2, 4, 7]
    返回节点 6
        访问右子树 8
    节点 8
        左子树为空，返回
        右子树为空，返回
        将 8 加入结果列表：[1, 2, 4, 7, 8]
    返回节点 6
        左右子树遍历完毕，将 6 加入结果列表：[1, 2, 4, 7, 8, 6]
    返回根节点 5
        左右子树遍历完毕，将 5 加入结果列表：[1, 2, 4, 7, 8, 6, 5]

最终的后序遍历结果是 [1, 2, 4, 7, 8, 6, 5]。


